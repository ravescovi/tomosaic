# !/usr/bin/env python# -*- coding: utf-8 -*-# ########################################################################## Copyright (c) 2015, UChicago Argonne, LLC. All rights reserved.         ##                                                                         ## Copyright 2015. UChicago Argonne, LLC. This software was produced       ## under U.S. Government contract DE-AC02-06CH11357 for Argonne National   ## Laboratory (ANL), which is operated by UChicago Argonne, LLC for the    ## U.S. Department of Energy. The U.S. Government has rights to use,       ## reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR    ## UChicago Argonne, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR        ## ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is     ## modified to produce derivative works, such modified software should     ## be clearly marked, so as not to confuse it with the version available   ## from ANL.                                                               ##                                                                         ## Additionally, redistribution and use in source and binary forms, with   ## or without modification, are permitted provided that the following      ## conditions are met:                                                     ##                                                                         ##     * Redistributions of source code must retain the above copyright    ##       notice, this list of conditions and the following disclaimer.     ##                                                                         ##     * Redistributions in binary form must reproduce the above copyright ##       notice, this list of conditions and the following disclaimer in   ##       the documentation and/or other materials provided with the        ##       distribution.                                                     ##                                                                         ##     * Neither the name of UChicago Argonne, LLC, Argonne National       ##       Laboratory, ANL, the U.S. Government, nor the names of its        ##       contributors may be used to endorse or promote products derived   ##       from this software without specific prior written permission.     ##                                                                         ## THIS SOFTWARE IS PROVIDED BY UChicago Argonne, LLC AND CONTRIBUTORS     ## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT       ## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS       ## FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL UChicago     ## Argonne, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,        ## INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,    ## BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;        ## LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER        ## CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT      ## LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN       ## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ## POSSIBILITY OF SUCH DAMAGE.                                             ## #########################################################################"""Module for image merging"""from __future__ import (absolute_import, division, print_function,                        unicode_literals)from tomosaic import blendimport tomosaicimport logginglogger = logging.getLogger(__name__)__author__ = "Rafael Vescovi"__credits__ = "Doga Gursoy"__copyright__ = "Copyright (c) 2015, UChicago Argonne, LLC."__docformat__ = 'restructuredtext en'__all__ = ['recon_block',           'recon_slice',           'prepare_slice',           'load_sino',           'register_recon']# -*- coding: utf-8 -*-"""Created on Fri Jul  1 10:57:31 2016@author: ravescovi"""import glob, time, itertoolsfrom tomosaic.morph.image import *import numpy as npimport tomopyimport dxchangedef recon_block(grid, shift_grid, slices, sino_step, save_folder, center_vec, ds_level=0, blend_method='max', sinogram_order=False,                algorithm=None, init_recon=None, ncore=None, nchunk=None, format='float32', **kwargs):    sino_ini = int(slices[0])    sino_end = int(slices[1])    mod_start_slice = 0    for i_slice in range(sino_ini, sino_end, sino_step):        print('############################################')        print('Reconstructing ' + str(i_slice))        # judge from which tile to retrieve sinos        pix_shift_grid = np.ceil(shift_grid)        pix_shift_grid[pix_shift_grid < 0] = 0        grid_lines = np.zeros(grid.shape[1])        slice_in_tile = np.zeros(grid.shape[1])        for col in range(grid.shape[1]):            bins = pix_shift_grid[:, col, 0]            grid_lines[col] = np.squeeze(np.digitize(i_slice, bins)) - 1            if grid_lines[col] == -1:                print("WARNING: The specified starting slice number does not allow for full sinogram construction. Trying next slice...")                mod_start_slice = 1                break            else:                mod_start_slice = 0            slice_in_tile[col] = i_slice - bins[grid_lines[col]]        if mod_start_slice is 1:            continue        print(grid_lines)        print(slice_in_tile)        row_sino = prepare_slice(grid, shift_grid, grid_lines, slice_in_tile, ds_level=ds_level, method=blend_method)        bin_cent = pix_shift_grid[:, 0, 0]        center_ind = np.squeeze(np.digitize(i_slice, bin_cent)) - 1        center_pos = center_vec[center_ind]        if format == 'int16':            out_sino = tomosaic.util.util.float2int(row_sino)        dxchange.write_tiff(np.squeeze(out_sino),                        fname=save_folder + '/sinos/sino_{:05d}_center_{:05d}'.format(i_slice, center_pos), dtype=format)        rec = recon_slice(row_sino, center_pos, sinogram_order=sinogram_order, algorithm=algorithm,                          init_recon=init_recon, ncore=ncore, nchunk=nchunk, **kwargs)        if format == 'int16':            print("NOTE: Output in 16-bit integer.")            rec = tomosaic.util.util.float2int(rec)        dxchange.write_tiff(rec, fname=save_folder + '/recon/recon_{:05d}_center_{:05d}'.format(i_slice, center_pos), dtype=format)def prepare_slice(grid, shift_grid, grid_lines, slice_in_tile, ds_level=0, method='max'):    sinos = [[]] * grid.shape[1]    for col in range(grid.shape[1]):        print("loading {:d}".format(col))        sinos[col] = load_sino(grid[grid_lines[col], col], slice_in_tile[col])    t = time.time()    row_sino = register_recon(grid, grid_lines, shift_grid, sinos, method=method)    print('stitch:           ' + str(time.time() - t))    print('final size:       ' + str(row_sino.shape))    t = time.time()    row_sino = tomopy.downsample(row_sino, level=ds_level)    print('downsample:           ' + str(time.time() - t))    print('new shape :           ' + str(row_sino.shape))    t = time.time()    row_sino = tomopy.remove_stripe_fw(row_sino, 2)    print('strip removal:           ' + str(time.time() - t))    # Minus Log    row_sino[np.abs(row_sino) < 1e-3] = 1    row_sino[row_sino > 1] = 1    row_sino = -np.log(row_sino)    row_sino[np.where(np.isnan(row_sino) == True)] = 0    return row_sinodef recon_slice(row_sino, center_pos, sinogram_order=False, algorithm=None,        init_recon=None, ncore=None, nchunk=None, **kwargs):    t = time.time()    ang = tomopy.angles(row_sino.shape[0])    rec = tomopy.recon(row_sino, ang, center=center_pos, sinogram_order=sinogram_order, algorithm=algorithm,        init_recon=init_recon, ncore=ncore, nchunk=nchunk, **kwargs)    print('recon:           ' + str(time.time() - t))    return recdef load_sino(filename, sino_n):    sino_n = int(sino_n)    sino, flt, drk = dxchange.read_aps_32id(filename, sino=(sino_n, sino_n + 1))    sino = tomopy.normalize(sino, flt, drk)    return np.squeeze(sino)def register_recon(grid, grid_lines, shift_grid, sinos, method='max'):    t = time.time()    file_list = [grid[grid_lines[col], col] for col in range(grid.shape[1])]    buff = np.zeros([1, 1], dtype='float32')    for col in range(len(file_list)):        x_shift = shift_grid[grid_lines[col], col, 1]        temp = np.copy(sinos[col])        buff = blend(buff, temp, [0, x_shift], method=method)    row_sino = buff.reshape([buff.shape[0], 1, buff.shape[1]])    assert_width = shift_grid[grid_lines[-1], -1, 1] + sinos[-1].shape[-1]    row_sino = row_sino[:, :, :assert_width].astype('float32')    print('stitch:           ' + str(time.time() - t))    print('final size:       ' + str(row_sino.shape))    return row_sino    # GRIDREC    # SIRT-FBP    # import astra, sirtfbp    # astra.plugin.register(sirtfbp.plugin)    # extra_options = {'filter_dir':'./filters'}    # num_iter = 100    # print 'iterations:           ' + str(num_iter)    # rec = tomopy.recon(sino, ang, center=center_pos, algorithm=tomopy.astra,    #	           options={'proj_type':'cuda','method':'SIRT-FBP','extra_options':extra_options,'num_iter':num_iter})    # tomopy.io.writer.write_tiff_stack(rec, fname=save_folder+'/sirtfbp'+str(num_iter)+'_'+str(grid_line)+'_'+str(sino_n))    # TV    # import astra, tvtomo    # num_iter=100    # print 'iterations:           ' + str(num_iter)    # astra.plugin.register(tvtomo.plugin)    # print astra.plugin.get_help('TV-FISTA')    # rec = tomopy.recon(sino, ang, center=center_pos, algorithm=tomopy.astra,    #	           options={'method':'TV-FISTA', 'proj_type':'cuda', 'num_iter':num_iter,    #	                    'extra_options':{'tv_reg':0.000005,'bmin':0.0,'print_progress':True}})    # tomopy.io.writer.write_tiff_stack(rec, fname=save_folder+'/fista'+str(num_iter)+'_'+str(grid_line)+'_'+str(sino_n))
